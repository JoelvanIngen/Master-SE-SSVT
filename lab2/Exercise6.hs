module Exercise6 where

import Data.List
import Test.QuickCheck


{-Test the functions symClos and trClos from the previous exercises. Devise your own test method for
 this. Try to use random test generation. Define reasonable properties to test. Can you use QuickCheck?
 How?
 Deliverables: test code, test report, indication of time spent -}


 {- Time spent 80min   Spending a lot of time debugging generators

    Test Report 
    This test verifies the core properties of two relational closure implementations, as follows:
    The properties tested are:

    symClos: Idempotence, Extensiveness, Symmetry;
    trClose: Idempotence, Extensiveness, Transitivity

    The test data is a random relation sample generated by me (using a custom arbitrary generator): 
    a list of randomly generated ordered pairs is used over a small integer domain, 
    and duplicates are removed as input for the property tests.

    QuickCheck is used to perform random tests on the above properties.
    In the current implementation, all of the above properties pass random tests.
 -}


--Custom generated test data
newtype MyRange = MyRange {getRel :: Rel Int }
    deriving (Show)

instance Arbitrary MyRange where
    arbitrary = do
        size <- chooseInt(1,5)
        --Define the scope of test data generation
        let dom = [0..size-1]         
        pairs <- listOf ((,) <$> elements dom <*> elements dom) 
        pure $ MyRange (nub pairs)   


--For symClos

--test extensiveness:  The original relation r 
--must be included in its symmetric closure
prop_extensiveness :: MyRange -> Bool
prop_extensiveness (MyRange r) = 
    let n = symClos r
    in all (`elem` n)r

--test symmetry: The result of a symmetric closure is itself a symmetric relation: 
--if (x, y) is in it, then (y, x) is also in it.
prop_symmetry :: MyRange -> Bool
prop_symmetry (MyRange r) = 
    let n = symClos r
    in all (\(x,y) -> (y,x) `elem` n) n

--test idempotence: Doing it again with symClos does not change the result
prop_idempotence :: MyRange -> Bool
prop_idempotence (MyRange r) = symClos (symClos r) == symClos r


--For trClos

--test extensiveness:  The original relation r 
--must be included in its symmetric closure
prop_extensiveness_trClos :: MyRange -> Bool
prop_extensiveness_trClos (MyRange r) = 
    let n = trClos r
    in all (`elem` n)r

--test transitivity: The result of a transitive closure is itself a transitive 
--relation. If (x, y) and (y, z) are in it, then (x, z) will also be in it.
prop_transitivity :: MyRange -> Bool
prop_transitivity (MyRange r) = 
    let n = trClos r
    in and [ (x,z) `elem` n | (x,y1) <- n, (y2,z) <- n, y1 == y2 ]   


--test idempotence: Doing it again with trClos does not change the result
prop_idempotence_trClos :: MyRange -> Bool
prop_idempotence_trClos (MyRange r) = trClos (trClos r) == trClos r


main:: IO() 
main = do
    quickCheck prop_extensiveness
    quickCheck prop_symmetry
    quickCheck prop_idempotence
    quickCheck prop_extensiveness_trClos
    quickCheck prop_transitivity
    quickCheck prop_idempotence_trClos



--------The code from the previous exercise-------

-- Binary relations as a list of pairs
type Rel a = [(a, a)]

-- Inverts a pair
pairInvert :: (a, a) -> (a, a)
pairInvert (x1, x2) = (x2, x1)

-- Recursively iterates through the list, adding each element and its reverse
-- before calling itself on the remainder of the list
symClos :: Ord a => Rel a -> Rel a
symClos [] = []
--symClos (x:xs) = x : pairInvert x : symClos xs
symClos xs = nub (sort (concatMap (\p -> [p, pairInvert p]) xs))


infixr 5 @@
(@@) :: Eq a => Rel a -> Rel a -> Rel a
r @@ s = nub [ (x,z) | (x,y) <- r, (w,z) <- s, y == w ]

closureStep :: Ord a => Rel a -> Rel a -> Rel a
closureStep rel orig =
    let new = rel @@ orig
        next = nub (rel ++ new)
    in
        if length next == length rel
            then rel
            else closureStep next orig

trClos :: Ord a => Rel a -> Rel a
trClos rel = sort $ closureStep rel rel










